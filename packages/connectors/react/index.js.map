<<<<<<< HEAD
{"version":3,"file":"index.js","sources":["src/getWrappedDisplayName.js","src/inject.jsx","src/listen.jsx","src/provider.jsx"],"sourcesContent":["export default Component => (\n  Component.displayName\n  || Component.name\n  || (Component.constructor && Component.constructor.name)\n  || 'Unknown'\n)\n","import React, { Component } from 'react'\nimport shallowEqual from 'fbjs/lib/shallowEqual'\nimport getWrappedDisplayName from './getWrappedDisplayName'\n\nconst defaultObject = {}\nconst withoutFunctions = object => Object\n  .keys(object)\n  .reduce(\n    (acc, key) => {\n      const value = object[key]\n      if (typeof value === 'function') return acc\n      return { ...acc, [key]: value }\n    },\n    defaultObject,\n  )\n\nexport default injectFunction => WrappedComponent => class extends Component {\n  static displayName = `inject(${getWrappedDisplayName(WrappedComponent)}`\n\n  static contextTypes = {\n    store: () => null, // this is to avoid importing prop-types\n  }\n\n  constructor(props, context) {\n    super(props, context)\n\n    this.first = true\n    this.state = {\n      injectedProps: {},\n    }\n  }\n\n  componentWillMount() {\n    const { store } = this.context\n\n    if (!store) {\n      const bold = 'font-weight: bolder; font-style: italic;'\n      // eslint-disable-next-line no-console\n      console.error(\n        `[k-ramel/react] Error in %cinject%c for the component %c${getWrappedDisplayName(WrappedComponent)}%c\\n` +\n        '\\t> The store needs to be provided by an ancestor of this component.\\n' +\n        '\\t> You can use %cprovider%c from %c@k-ramel/react%c or %cProvider%c from %creact-redux%c.\\n\\n' +\n        'Check the documentation for an example at https://github.com/alakarteio/k-ramel#connect-it-with-reactjs\\n',\n        bold, '', bold, '', bold, '', bold, '', bold, '', bold, '',\n      )\n      return\n    }\n\n    // subscribe\n    this.unsubscribe = store.subscribe(() => {\n      this.inject()\n    })\n\n    // run in once\n    this.inject()\n  }\n\n  componentWillReceiveProps(nextProps) {\n    this.inject(nextProps)\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    if (this.first) return true\n\n    return !(\n      shallowEqual(this.props, nextProps)\n      && shallowEqual(\n        withoutFunctions(nextState.injectedProps),\n        withoutFunctions(this.state.injectedProps),\n      )\n    )\n  }\n\n  componentWillUnmount() {\n    this.unsubscribe()\n  }\n\n  inject = (nextProps) => {\n    this.setState(state => ({\n      ...state,\n      injectedProps: injectFunction(this.context.store, nextProps || this.props),\n    }))\n  }\n\n  render() {\n    if (this.first) this.first = false\n\n    return (\n      <WrappedComponent\n        /* this is parent props */\n        {...this.props}\n        /* this is injected props from hoc */\n        {...this.state.injectedProps}\n      />\n    )\n  }\n}\n","import React, { Component } from 'react'\nimport getWrappedDisplayName from './getWrappedDisplayName'\n\nconst defaultListeners = []\n\nconst toActionFactory = (name) => {\n  const suffix = `${name ? '>' : ''}${name || ''}`\n  return type => `@@krm/LISTENERS>${type}${suffix}`\n}\n\nexport default (listeners = defaultListeners, name) => (WrappedComponent) => {\n  const toAction = toActionFactory(name)\n\n  return class extends Component {\n    static displayName = `listen(${getWrappedDisplayName(WrappedComponent)}`\n\n    static contextTypes = {\n      store: () => null, // this is to avoid importing prop-types\n    }\n\n    componentWillMount() {\n      const { store } = this.context\n\n      store.listeners.add(listeners)\n      store.dispatch(toAction('ADDED'))\n    }\n\n    componentWillUnmount() {\n      const { store } = this.context\n\n      store.dispatch(toAction('REMOVING'))\n      store.listeners.remove(listeners)\n    }\n\n    render() {\n      return <WrappedComponent {...this.props} />\n    }\n  }\n}\n","/* eslint-disable import/prefer-default-export */\nimport React, { Component } from 'react'\nimport getWrappedDisplayName from './getWrappedDisplayName'\n\nexport default store => WrappedComponent => class extends Component {\n  static displayName = `provider(${getWrappedDisplayName(WrappedComponent)})`\n\n  static childContextTypes = {\n    store: () => null, // this is to avoid importing prop-types\n  }\n\n  getChildContext() {\n    return { store }\n  }\n\n  componentWillMount() {\n    store.dispatch('@@krml/INIT')\n  }\n\n  render() {\n    return <WrappedComponent {...this.props} />\n  }\n}\n"],"names":["Component","displayName","name","constructor","defaultObject","withoutFunctions","Object","keys","object","reduce","acc","key","value","defaultListeners","props","context","inject","nextProps","setState","state","injectFunction","_this","store","first","this","unsubscribe","subscribe","bold","error","getWrappedDisplayName","WrappedComponent","nextState","shallowEqual","injectedProps","React","contextTypes","dispatch","childContextTypes","listeners","toAction","suffix","type","toActionFactory","add","remove"],"mappings":"0YAAA,yBACEA,EAAUC,aACPD,EAAUE,MACTF,EAAUG,aAAeH,EAAUG,YAAYD,MAChD,m+BCACE,KACAC,EAAmB,mBAAUC,OAChCC,KAAKC,GACLC,OACC,SAACC,EAAKC,OACEC,EAAQJ,EAAOG,SACA,mBAAVC,EAA6BF,OAC5BA,4HAAMC,EAAMC,KAE1BR,ICVES,iCDa2B,sDAOnBC,EAAOC,4EACXD,EAAOC,aAqDfC,OAAS,SAACC,KACHC,SAAS,wBACTC,iBACYC,EAAeC,EAAKN,QAAQO,MAAOL,GAAaI,EAAKP,cAtDjES,OAAQ,IACRJ,oGAMGG,EAAUE,KAAKT,QAAfO,SAEHA,OAcAG,YAAcH,EAAMI,UAAU,aAC5BV,gBAIFA,kBAlBGW,EAAO,mDAELC,MACN,2DAA2DC,EAAsBC,uRAIjFH,EAAM,GAAIA,EAAM,GAAIA,EAAM,GAAIA,EAAM,GAAIA,EAAM,GAAIA,EAAM,uDAcpCV,QACnBD,OAAOC,iDAGQA,EAAWc,WAC3BP,KAAKD,SAGPS,EAAaR,KAAKV,MAAOG,IACtBe,EACD3B,EAAiB0B,EAAUE,eAC3B5B,EAAiBmB,KAAKL,MAAMc,qEAM3BR,sDAWDD,KAAKD,QAAOC,KAAKD,OAAQ,GAG3BW,gBAACJ,OAEKN,KAAKV,MAELU,KAAKL,MAAMc,uBA5E4CjC,eAC1DC,sBAAwB4B,EAAsBC,KAE9CK,oBACE,kBAAM,yCEhBO,iNAQXb,wDAIHc,SAAS,uDAIRF,gBAACJ,EAAqBN,KAAKV,cAhBoBd,eACjDC,wBAA0B4B,EAAsBC,SAEhDO,yBACE,kBAAM,mCDEDC,yDAAYzB,EAAkBX,sBAAS,SAAC4B,WAChDS,EANgB,SAACrC,OACjBsC,GAAYtC,EAAO,IAAM,KAAKA,GAAQ,WACrC,qCAA2BuC,EAAOD,GAIxBE,CAAgBxC,gMAUrBoB,EAAUE,KAAKT,QAAfO,QAEFgB,UAAUK,IAAIL,KACdF,SAASG,EAAS,6DAIhBjB,EAAUE,KAAKT,QAAfO,QAEFc,SAASG,EAAS,eAClBD,UAAUM,OAAON,2CAIhBJ,gBAACJ,EAAqBN,KAAKV,cAtBjBd,eACZC,sBAAwB4B,EAAsBC,KAE9CK,oBACE,kBAAM"}
=======
{"version":3,"file":"index.js","sources":["src/getWrappedDisplayName.js","src/inject.jsx","src/listen.jsx","src/provider.jsx"],"sourcesContent":["export default Component => (\n  Component.displayName\n  || Component.name\n  || (Component.constructor && Component.constructor.name)\n  || 'Unknown'\n)\n","import React, { Component } from 'react'\nimport shallowEqual from 'fbjs/lib/shallowEqual'\nimport getWrappedDisplayName from './getWrappedDisplayName'\n\nconst defaultObject = {}\nconst withoutFunctions = object => Object\n  .keys(object)\n  .reduce(\n    (acc, key) => {\n      const value = object[key]\n      if (typeof value === 'function') return acc\n      return { ...acc, [key]: value }\n    },\n    defaultObject,\n  )\n\nexport default injectFunction => WrappedComponent => class extends Component {\n  static displayName = `inject(${getWrappedDisplayName(WrappedComponent)}`\n\n  static contextTypes = {\n    store: () => null, // this is to avoid importing prop-types\n  }\n\n  constructor(props, context) {\n    super(props, context)\n\n    this.first = true\n    this.state = {\n      injectedProps: {},\n    }\n  }\n\n  componentWillMount() {\n    // subscribe\n    this.unsubscribe = this.context.store.subscribe(() => {\n      this.inject()\n    })\n\n    // run in once\n    this.inject()\n  }\n\n  componentWillReceiveProps(nextProps) {\n    this.inject(nextProps)\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    if (this.first) return true\n\n    return !(\n      shallowEqual(this.props, nextProps)\n      && shallowEqual(\n        withoutFunctions(nextState.injectedProps),\n        withoutFunctions(this.state.injectedProps),\n      )\n    )\n  }\n\n  componentWillUnmount() {\n    this.unsubscribe()\n  }\n\n  inject = (nextProps) => {\n    this.setState(state => ({\n      ...state,\n      injectedProps: injectFunction(this.context.store, nextProps || this.props),\n    }))\n  }\n\n  render() {\n    if (this.first) this.first = false\n\n    return (\n      <WrappedComponent\n        /* this is parent props */\n        {...this.props}\n        /* this is injected props from hoc */\n        {...this.state.injectedProps}\n      />\n    )\n  }\n}\n","import React, { Component } from 'react'\nimport getWrappedDisplayName from './getWrappedDisplayName'\n\nconst defaultListeners = []\n\nconst toActionFactory = (name) => {\n  const suffix = `${name ? '>' : ''}${name || ''}`\n  return type => `@@krml/LISTENERS>${type}${suffix}`\n}\n\nexport default (listeners = defaultListeners, name) => (WrappedComponent) => {\n  const toAction = toActionFactory(name)\n\n  return class extends Component {\n    static displayName = `listen(${getWrappedDisplayName(WrappedComponent)}`\n\n    static contextTypes = {\n      store: () => null, // this is to avoid importing prop-types\n    }\n\n    componentWillMount() {\n      const { store } = this.context\n\n      store.listeners.add(listeners)\n      store.dispatch(toAction('ADDED'))\n    }\n\n    componentWillUnmount() {\n      const { store } = this.context\n\n      store.dispatch(toAction('REMOVING'))\n      store.listeners.remove(listeners)\n    }\n\n    render() {\n      return <WrappedComponent {...this.props} />\n    }\n  }\n}\n","/* eslint-disable import/prefer-default-export */\nimport React, { Component } from 'react'\nimport getWrappedDisplayName from './getWrappedDisplayName'\n\nexport default store => WrappedComponent => class extends Component {\n  static displayName = `provider(${getWrappedDisplayName(WrappedComponent)})`\n\n  static childContextTypes = {\n    store: () => null, // this is to avoid importing prop-types\n  }\n\n  getChildContext() {\n    return { store }\n  }\n\n  componentWillMount() {\n    store.dispatch('@@krml/INIT')\n  }\n\n  render() {\n    return <WrappedComponent {...this.props} />\n  }\n}\n"],"names":["Component","displayName","name","constructor","defaultObject","withoutFunctions","Object","keys","object","reduce","acc","key","value","defaultListeners","props","context","inject","nextProps","setState","state","injectFunction","_this","store","first","unsubscribe","this","subscribe","nextState","shallowEqual","injectedProps","React","WrappedComponent","getWrappedDisplayName","contextTypes","dispatch","childContextTypes","listeners","toAction","suffix","type","toActionFactory","add","remove"],"mappings":"0YAAA,yBACEA,EAAUC,aACPD,EAAUE,MACTF,EAAUG,aAAeH,EAAUG,YAAYD,MAChD,m+BCACE,KACAC,EAAmB,mBAAUC,OAChCC,KAAKC,GACLC,OACC,SAACC,EAAKC,OACEC,EAAQJ,EAAOG,SACA,mBAAVC,EAA6BF,OAC5BA,4HAAMC,EAAMC,KAE1BR,ICVES,iCDa2B,sDAOnBC,EAAOC,4EACXD,EAAOC,aAsCfC,OAAS,SAACC,KACHC,SAAS,wBACTC,iBACYC,EAAeC,EAAKN,QAAQO,MAAOL,GAAaI,EAAKP,cAvCjES,OAAQ,IACRJ,yGAOAK,YAAcC,KAAKV,QAAQO,MAAMI,UAAU,aACzCV,gBAIFA,2DAGmBC,QACnBD,OAAOC,iDAGQA,EAAWU,WAC3BF,KAAKF,SAGPK,EAAaH,KAAKX,MAAOG,IACtBW,EACDvB,EAAiBsB,EAAUE,eAC3BxB,EAAiBoB,KAAKN,MAAMU,qEAM3BL,sDAWDC,KAAKF,QAAOE,KAAKF,OAAQ,GAG3BO,gBAACC,OAEKN,KAAKX,MAELW,KAAKN,MAAMU,uBA7D4C7B,eAC1DC,sBAAwB+B,EAAsBD,KAE9CE,oBACE,kBAAM,yCEhBO,iNAQXX,wDAIHY,SAAS,uDAIRJ,gBAACC,EAAqBN,KAAKX,cAhBoBd,eACjDC,wBAA0B+B,EAAsBD,SAEhDI,yBACE,kBAAM,mCDEDC,yDAAYvB,EAAkBX,sBAAS,SAAC6B,WAChDM,EANgB,SAACnC,OACjBoC,GAAYpC,EAAO,IAAM,KAAKA,GAAQ,WACrC,sCAA4BqC,EAAOD,GAIzBE,CAAgBtC,gMAUrBoB,EAAUG,KAAKV,QAAfO,QAEFc,UAAUK,IAAIL,KACdF,SAASG,EAAS,6DAIhBf,EAAUG,KAAKV,QAAfO,QAEFY,SAASG,EAAS,eAClBD,UAAUM,OAAON,2CAIhBN,gBAACC,EAAqBN,KAAKX,cAtBjBd,eACZC,sBAAwB+B,EAAsBD,KAE9CE,oBACE,kBAAM"}
>>>>>>> master
